#!/usr/bin/env python
import rospy
import math
from sensor_msgs.msg import Joy

# Joystick/gamepad axis map
AXIS_X0 = 0
AXIS_X1 = 1
BUTTON = 0

class OperatorNode:

    def __init__(self):

        rospy.init_node('operator_node')
        rospy.on_shutdown(self.shutdown)
        self.name = rospy.get_name()

        # Get ROS Parameters
        self.flip_axes = rospy.get_param('~flip_axes', False)
        self.direction_x0 = float(rospy.get_param('~dr_x0', 1))
        self.direction_x1 = float(rospy.get_param('~dr_x1', 1))
        self.max_velocity = float(rospy.get_param('~max_velocity'))

        # Create publisher and subscriber
        self.pub_signal = rospy.Publisher('operator_signal', Joy, queue_size=10)
        self.pub_signal_normalized = rospy.Publisher('operator_signal/normalized', Joy, queue_size=10)
        self.sub = rospy.Subscriber('operator_signal/raw', Joy, self.remapJoyToOperatorSignal)

    def __normalizedAxesSignalFromMsg(self, msg):
        hr0 = self.direction_x0 * msg.axes[AXIS_X0]
        hr1 = self.direction_x1 * msg.axes[AXIS_X1]
        htheta = math.atan2(hr1, hr0)
        hscale = min(math.sqrt(hr0**2 + hr1**2), 1.0)
        h = [hscale * math.cos(htheta), hscale * math.sin(htheta)]
        if self.flip_axes:
            h_out = [h[1], h[0]]
        else:
            h_out = h
        return h_out

    def __buttonSignalFromMsg(self, msg):
        return [msg.buttons[BUTTON]]

    def __publishOperatorSignal(self, axes_signal, button_signal):
        msg = Joy()
        msg.header.stamp = rospy.Time.now()
        msg.axes = axes_signal
        msg.buttons = button_signal
        self.pub_signal.publish(msg)

    def __publishNormalizedOperatorSignal(self, normalized_axes_signal, button_signal):
        msg = Joy()
        msg.header.stamp = rospy.Time.now()
        msg.axes = normalized_axes_signal
        msg.buttons = button_signal
        self.pub_signal_normalized.publish(msg)

    def remapJoyToOperatorSignal(self, msg):
        """Listens for Joy messages and publishes operator signals."""
        hnorm = self.__normalizedAxesSignalFromMsg(msg)
        button_signal = self.__buttonSignalFromMsg(msg)
        self.__publishOperatorSignal(
            [self.max_velocity*hnorm[0], self.max_velocity*hnorm[1]],
            button_signal
        )
        self.__publishNormalizedOperatorSignal(
            hnorm, button_signal
        )

    def spin(self):
        try:
            rospy.spin()
        except KeyboardInterrupt:
            rospy.logwarn('{self.name}: User interrupt, quitting...')

    def shutdown(self):
        self.sub.unregister()
        rospy.loginfo(f'{self.name}: Shutting down')

if __name__ == '__main__':
    OperatorNode()
    rospy.spin()

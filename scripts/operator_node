#!/usr/bin/env python
import rospy
import numpy
from sensor_msgs.msg import Joy

################
# User input
use_raw = False
################

# Joystick/gamepad axis map
AXIS_X = 0
AXIS_Y = 1
BUTTON = 0

class OperatorNode:

    def __init__(self):

        # Setup
        self.max_velocity = float(rospy.get_param('~max_velocity'))
        self._parse = self._useRaw if use_raw else self._ensureIsometry

        # Create publisher and subscriber
        self.pub = rospy.Publisher('operator_signal', Joy, queue_size=1)
        rospy.Subscriber('operator_signal/raw', Joy, self.remapJoyToOperatorSignal)

    def _ensureIsometry(self, hraw):
        htheta = numpy.arctan2(hraw[1], hraw[0])
        return min(numpy.linalg.norm(hraw), 1.0) * numpy.array([numpy.cos(htheta), numpy.sin(htheta)])

    def _useRaw(self, hraw):
        return hraw

    def remapJoyToOperatorSignal(self, msgin):
        """Listens for Joy messages and publishes operator signals."""

        # Extract raw operator signal and parse
        hraw = numpy.array([msgin.axes[AXIS_X], msgin.axes[AXIS_Y]], dtype=float)
        h = self.max_velocity * self._parse(hraw)

        # Create message and publish
        msgout = Joy()
        msgout.header.stamp = rospy.Time.now()
        msgout.axes = h.tolist()
        msgout.buttons = [msgin.buttons[BUTTON]]
        self.pub.publish(msgout)

if __name__=='__main__':
    rospy.init_node('operator_node', anonymous=True)
    OperatorNode()
    rospy.spin()

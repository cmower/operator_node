#!/usr/bin/env python
import rospy
import numpy
from sensor_msgs.msg import Joy

################
# User input
use_raw = False
################

# Parameters
PARAM_INPUT_TOPIC = '~input_topic'
PARAM_MAX_VELOCITY = '~max_velocity'

INTOPIC = 'operator_signal/raw'
OUTTOPIC = 'operator_signal'

# Joystick/gamepad axis map
AXIS_X = 0
AXIS_Y = 1
BUTTON = 0

class OperatorNode:

    def __init__(self):

        # Grab max velocity
        self.max_velocity = float(rospy.get_param(PARAM_MAX_VELOCITY))

        # Setup _parse method
        if use_raw:
            self._parse = self._useRaw
        else:
            self._parse = self._ensureIsometry

        # Create publishers
        self.pub = rospy.Publisher(OUTTOPIC, Joy, queue_size=1)

        # Subscribe to joy node
        rospy.Subscriber(INTOPIC, Joy, self.remapJoyToOperatorSignal)

    def _ensureIsometry(self, hraw):
        htheta = numpy.arctan2(hraw[1], hraw[0])
        return min(numpy.linalg.norm(hraw), 1.0) * numpy.array([numpy.cos(htheta), numpy.sin(htheta)])

    def _useRaw(self, hraw):
        return hraw

    def remapJoyToOperatorSignal(self, msgin):
        """Listens for Joy messages and publishes operator signals."""

        # Extract raw operator signal and parse
        hraw = numpy.array([msgin.axes[AXIS_X], msgin.axes[AXIS_Y]], dtype=float)
        h = self.max_velocity * self._parse(hraw)

        # Create message and publish
        msgout = Joy()
        msgout.header.stamp = rospy.Time.now()
        msgout.axes = h.tolist()
        msgout.buttons = [msgin.buttons[BUTTON]]
        self.pub.publish(msgout)

if __name__=='__main__':
    rospy.init_node('operator_node', anonymous=True)
    OperatorNode()
    rospy.spin()
